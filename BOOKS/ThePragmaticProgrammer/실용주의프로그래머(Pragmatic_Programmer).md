## DAY 02 (2022.05.14)

## 서문 ~ 1장. 실용주의 철학

`📝 오늘 읽은 범위`

추천사

2판 서문

1판 서문

### **1장. 실용주의 철학**

항목 1. 당신의 인생이다

항목 2. 고양이가 내 소스 코드를 삼켰어요

항목 3. 소프트웨어 엔트로피

항목 4. 돌멩이 수프와 삶은 개구리

항목 5. 적당히 괜찮은 소프트웨어

항목 6. 지식 포트폴리오

항목 7. 소통하라!

`📝 오늘 TIL 3줄 요약`

1. 어떤 특정 기술에 매이면 안 된다. 배경 지식은 컴퓨터 과학의 기본 원리에 대한 이해에서 생겨나고, 경험은 다양한 종류의 실제 프로젝트들을 수행해 봄으로써 얻을 수 있다. 이론과 실천의 결합이 여러분을 강하게 만든다.
**>> 끊임없이 학습하기**
2. 실용주의 프로그래머는 무엇이 다른가? 우리는 문제와 해법에 접근하는 태도와 방식, 철학에 차이가 있다고 생각한다. 실용주의 프로그래머는 직면한 문제 너머를 고민한다. 문제를 더 큰 맥락에 놓고 더 큰 그림을 보려고 노력한다.
**>> 나무가 아닌 숲을 보기**
3. 뭘 가졌느냐 만이 아니라 그걸 어떻게 포장하느냐도 중요하다. 효과적인 소통 없이는 아무리 훌륭한 아이디어라도 고립되고 만다.
개발자로서 우리는 여러 입장에서 소통해야 한다.
외부와 단절된 환경에서 작업하지 않는 이상 우리는 의사소통을 해야 한다. 그 소통이 더 효과적일수록 좀 더 많은 영향력을 갖게 될 것이다.
**>> 끊임없이 소통하기** (단, 효과적으로!)

`💡 책에서 기억하고 싶은 내용` 

### 2판 서문

> 기술은 바뀌었을지 모르나 사람은 바뀌지 않았다. 20년 전에 유용했던 실천 방법이나 접근 방식은 여전히 유용하다.
( 중 략 )
여러분의 기예(craft)에 관심을 갖고 몰두하라.
하지만 잊지 말라. 무엇보다 중요한 것은 즐기는 것이다.
( 중 략 )
혹시 책을 읽다가 전에 본 적 없는 단어와 진짜로 마주치게 된다면 그냥 건너뛰지 말라. 시간을 들여 웹이나 컴퓨터 과학 교과서에서 찾아보라
> 

### 1판 서문

> 프로그래밍은 기예(craft)다. ( 중 략 ) 여러분은 매일 작은 기적을 만드는 것이다. 참 어려운 직업이다.
( 중 략 )
이것이 실용주의가 필요한 이유다. 어떤 특정 기술에 매이면 안 된다. 배경 지식은 컴퓨터 과학의 기본 원리에 대한 이해에서 생겨나고, 경험은 다양한 종류의 실제 프로젝트들을 수행해 봄으로써 얻을 수 있다. 이론과 실천의 결합이 여러분을 강하게 만든다.

**무엇이 실용주의 프로그래머를 만드는가?**
모든 개발자는 유일무이하다. ( 중 략 ) 하지만 그래도 실용주의 프로그래머들은 특징들 가운데 많은 수를 공유한다.

1. 얼리 어댑터 또는 새로운 것에 빨리 적응하는 사람
2. 호기심이 많은 사람
3. 비판적인 사고의 소유자
4. 현실주의자
5. 다방면에 능숙한 사람.

( 중 략 )
실용주의 프로그래머가 되고 싶다면 어떤 일을 하면서 자기가 무엇을 하고 있는지 생각해야만 한다. 모든 개발 과정에서, 매일, 내리는 모든 결정을 끊임없이 비판적으로 평가해야 한다. 절대 기계적으로 일하지 말라.

**실용주의 프로그래머와 규모가 큰 팀**
소프트웨어 구축은 공학적인 규율에 따라 이루어져아 한다. 하지만 그렇다고 개개인이 솜씨를 발휘할 여지가 없는 것은 아니다.
( 중 략 )
”우리가 단지 돌을 자를지라도 언제나 대성당을 마음속에 그려야 한다.”
프로젝트의 전체 구조 속에는 언제나 개성과 장인 정신(craftsmanship)을 발휘할 여지가 있다.

**끊임없는 과정**
카이젠 : 꾸준히 조금씩 자주 개량한다는 뜻의 일본어
카이젠은 개인에게도 적용할 수 있다.
> 

### 실용주의 철학 (A Pragmatic Philosophy)

> 실용주의 프로그래머는 무엇이 다른가? 우리는 문제와 해법에 접근하는 태도와 방식, 철학에 차이가 있다고 생각한다. 실용주의 프로그래머는 직면한 문제 너머를 고민한다. 문제를 더 큰 맥락에 놓고 더 큰 그림을 보려고 노력한다.
( 중 략 )
물론 이 모두를 잘 해내려면 넓은 기반 지식과 경험을 가져야한다. 끊임없이 계속 배워야 한다.
( 중 략 )
실용주의 프로그래밍은 실용적 사고의 철학에 뿌리를 두고 있다.
> 

**Topic 1. 당신의 인생이다**

> 우리의 답은 한결같다.
”왜 직접 바꾸지 않습니까?”
구직자에게 주도권이 있는 직업 순위를 뽑아 보면 소프트웨어 개발은 제일 윗부분에 자리잡을 것이다.
( 중 략 ) 하지만 개발자들은 변화를 피하는 것 같다. 구석에 쭈그린 채 상황이 좋아지리라 생각한다.
( 중 략 )
당신에게는 스스로의 행동을 직접 결정할 수 있는 힘이 있다. ( 중 략 ) 문제를 고치기 위해 노력하라.
( 중 략 )
기술에 뒤쳐지는 기분이 든다면 여가 시간을 쪼개서 재미있어 보이는 것을 공부하라. 여러분 자신에게 투자하는 것이니 업무 외 시간에 하는 것이 옳다.
> 

**Topic 2. 고양이가 내 소스 코드를 삼켰어요.**

> 실용주의 프로그래머는 자신의 경력에 책임을 지고, 자신의 무지나 실수를 주저 없이 인정한다.
( 중 략 )
이런 일이 일어나면 우리는 가능한 한 전문가답게 처리하려고 노력한다. 이는 정직하고 솔직해져야 한다는 것이다. 우리는 자신의 능력에 자부심을 가질 수 있지만, 실수나 무지 같은 단점도 인정해야만 한다.

**팀 내 신뢰**
연구에 따르면 창의성과 공동 작업에는 팀 내의 신뢰가 절대적으로 필요하다고 한다.

**책임지기**
책임은 여러분이 적극적으로 동의하는 것이다. 개인적으로 최선을 다하는 것이 전부가 아니다.
( 중 략 ) 자신의 가치관과 판단에 따라 결정해야 할 것이다.
결과에 따른 책임을 지기로 했다면 나중에 그 결과를 감당해야 할 것이다.
( 중 략 )
다른 사람 혹은 다른 무언가를 비난하거나 변명을 만들어 내지 말라. ( 중 략 ) 해결책을 찾아내야 하는 사람은 여러분이다.
( 중 략 )
변명 말고 대안을 제시하라. 안된다고 하지 말고 상황을 개선하기 위해 무엇을 할 수 있는지 설명하라.
( 중 략 )
부탁을 어려워하지 말고 도움이 필요하다는 사실을 인정하라.

**도전해 볼 것**
- “잘 모르겠어요.” 라고 말했다면, 꼭 바로 이어서 “하지만 알아볼게요.”라고 말하라. 모른다는 것은 인정하더라도 전문가답게 책임을 지는 좋은 방법이다.
> 

**Topic 3. 소프트웨어 엔트로피**

> 소프트웨어가 부패하는 데에는 많은 요소가 관여한다.
( 중 략 )
깨진 창문.
( 중 략 ) 결국 버려진 듯한 느낌은 현실이 되어 버린다.
심리학자들은 절망감이 전염된다는 연구를 발표했다.
( 중 략 )
나쁜 설계, 잘못된 결정, 혹은 형편없는 코드 등이 모두 깨진 창문이다. 발견하자마자 고쳐라.
깨끗하고 잘 기능하던 시스템이 일단 창문이 깨지기 시작하면 급속도로 악화되는 경우를 많이 보았다. 방치는 다른 어떤 요인보다도 부패를 더 가속시킨다.
엔트로피가 우리를 지배하도록 내버려 두지 말라.

**우선, 망가트리지 말라**
어떤 위기가 찾아왔다고 해서 부가적인 피해를 일으키지 말라. 깨진 창문은 하나로 충분하다.
깨진 창문이 꽤 있는 프로젝트에서 일할 때는 ‘나머지 코드가 전부 쓰레기니까 나도 그렇게 하지 뭐.’ 라는 사고에 빠지기 너무 쉽다.
명심하라. “깨진 창문은 없어야 한다.”

**도전해 볼 것**
- 창문이 처음 깨졌을 때 목소리를 낼 수 있겠는가?
> 

**Topic 4 돌멩이 수프와 삶은 개구리**

> 미래를 살짝이라도 보여 주면 사람들은 도와주기 위해 모여들 것이다.
**[ Tip 6 : 변화의 촉매가 되라. ]**

**마을 사람의 경우**
우리는 매일 이런 상황에 처한다. 우리도 모르는 새 서서히 상황이 악화된다.
( 중 략 )
개구리의 문제는 깨진 창문 이론과는 논점이 다르다는 것에 주의하라. 깨진 창문 이론에서는 다른 사람들이 아무도 주의를 기울이지 않는다는 걸 알기에 사람들이 엔트로피에 대해 ㅆ아ㅜㄹ 의지를 잃는다고 했다. 반면에 개구리는 단지 변화를 감지하지 못하는 것이다.
그런 개구리처럼 되지 말라. 큰 그림에 늘 주의를 기울여라.

**도전해 볼 것**
진짜로 주변을 살피고 의식하는 습관을 들여라. 그리고 여러분의 프로젝트에 대해서도 똑같이 하라.
> 

**Topic 5. 적당히 괜찮은 소프트 웨어**

> ‘적당히 괜찮은’ 이라는 표현은 너절하거나 형편없는 코드를 의미하지 않는다. ( 중 략 ) 생산해 낸 것이 적당히 괜찮게 사용자의 요구를 충족하는지 결정하는 과정에 사용자가 참여할 기회를 가져야 한다는 건ㅅ이다.

**타협 과정에 사용자를 참여시켜라**
만드는 시스템의 범위(scope)와 품질은 해당 시스템의 요구 사항 중 하나로 논의되어야 한다.
**[ Tip 8. 품질을 요구 사항으로 만들어라. ]

멈춰야 할 때를 알라**
완벽하게 훌륭한 프로그램을 과도하게 장식하거나 지나칠 정도로 다듬느라 망치지 말라. 완벽하지 않을 수도 있다. 그래도 괜찮다. 완벽해지기란 불가능하다.
> 

**Topic 6. 지식 포트폴리오**

> *지식에 대한 투자가 언제나 최고의 이윤을 낸다 -벤저민 프랭클린*

지식과 경험이야말로 가장 중요하고 날마다 쓰이는 전문가 자산이다. 하지만 불행히도 이 자산은 ‘기한이 있는 자산(expiring assets)’이다.
( 중 략 )
새로운 것을 배우는 능력은 가장 중요한 전략 자산이다.

**지식 포트폴리오**
비결은 일단 스스로 한 번 해본 다음, 습관을 들이는 것이다. 따라 할 절차를 만든 다음 여러분의 뇌에 각인될 때까지 반복하라

**포트폴리오 만들기**
- 주기적인 투자
- 다각화
- 리스크 관리 : 기술 달걀을 모두 한 바구니에 담지 말라.
- 싸게 사서 비싸게 팔기
- 검토 및 재조정 : 이 산업은 매우 동적이다.

**목표**
- 매년 새로운 언어를 최소 하나는 배워라. : 몇 가지 서로 다른 접근법을 알면 사고를 확장하고 판에 박힌 사고에 갇히는 것을 예방하는 데에 도움이 된다.
- 기술 서적을  한 달에 한 권씩 읽어라 : 현재 프로젝트와 관련 있는 흥미로운 주제의 기술 서적을 서멎에서 찾아보라. 습관이 들면 한 달에 한 권씩 읽어라. 현재 사용하는 기술을 일단 완전히 익혔다면, 가지를 쳐서 지금 하는 프로젝트와 관련 없는 분야까지 공부 범위를 넓혀라.
- 기술 서적이 아닌 책도 읽어라.
- 수업을 들어라
- 지역 사용자 단체나 모임에 참가하라. : 고립은 경력에 치명적일 수 있다. 적극적으로 참여하라
- 다른 환경에서 실험해보라
- 요즘 흐름을 놓치지 말라

투자를 지속하는 것이 중요하다. 한 기술의 새로운 용어나 기능에 익숙해지면 다음으로 나아가라. 또 다른 것을 배워라.
이런 기술들을 프로젝트에서 영영 사용하지 않거나 심지어 자신의 이력서에 올려놓지 않아도 상관없다. 학습 과정에서 사고가 확장될 것이다. ( 중 략 ) 프로젝트에서 그 기술을 사용하지 않을지라도 어쩌면 몇 가지 아이디어를 도입할 수 있을 것이다.

**학습의 기회**
다른 사람과 이야기함으로써 개인 네트워크를 구축하는 데 도움이 되기도 하고, 답을 찾는 도중에 별로 관련이 없어 보이는 문제에 대한 해답을 찾아서 놀라는 일도 생길 것이다. 게다가 포트폴리오는 그사이 계속 커진다.

**비판적 사고**
중요한 점은 읽거나 듣는 것에 대해 비판적으로 생각하는 것이다. 포트폴리오에 있는 지식을 정확히 유지할 수 있도록 하고 업체나 매체의 과대광고에 흔들리지 않아야 함을 명심하라. 
****( 중 략 )
비판적 사고는 그 자체만으로 하나의 학문을 이룬다. 비판적 사고에 대하여 최대한 많이 읽고 공부하기를 권한다.
- 왜냐고 다섯 번 묻기
- 누구에게 이익이 되나?
- 어떤 맥락인가?
- 언제 혹은 어디서 효과가 있을까?
- 왜 이것이 문제인가?
> 

**Topic 7. 소통하라**

> 뭘 가졌느냐 만이 아니라 그걸 어떻게 포장하느냐도 중요하다. 효과적인 소통 없이는 아무리 훌륭한 아이디어라도 고립되고 만다.
개발자로서 우리는 여러 입장에서 소통해야 한다.

**청중을 알라**
그저 말하는 것만으로는 부족하다. 전달하는 내용을 제대로 전달하고 있는 경우에만 소통하고 있다고 할 수 있다. 그렇게 하기 위해서는 청중의 요구와 관심, 능력을 이해할 필요가 있다.
( 중 략 )
다른 모든 형태의 의사소통과 마찬가지로 여기서도 비결은 피드백을 모으는 것이다. 그저 질문을 기다리지 말고 먼저 물어보라. 손짓, 몸짓, 표정을 관찰하라.

**말하고 싶은 게 무언지 알라**
제대로 전달하는 데 필요한 전략을 몇 개 세워라

**때를 골라라**
말하는 내용뿐 아니라 말하는 시점도 적절하게 하라. 가끔 ‘ ~에 대해 이야기할 좋은 때일까?’ 라는 간단한 질문을 해 보는 것만으로도 충분하다.

**스타일을 골라라**
전달하는 스타일을 청중에 어울리도록 조정하라.

**멋져 보이게 하라.**
너무 많은 개발자-그리고 그들의 관리자-가 문서를 만들 때 내용에만 집중한다. 우리 생각에 이것은 실수다.

**청중을 참여시켜라.**
가능하다면 독자가 문서 초안에 참여하도록 하라. 피드백을 받고 그들의 머릿속을 도용하라.

**경청하라

응답하라
[ Tip 12. 무엇을 말하는가와 어떻게 말하는가 모두 중요하다. ]**

외부와 단절된 환경에서 작업하지 않는 이상 우리는 의사소통을 해야 한다. 그 소통이 더 효과적일수록 좀 더 많은 영향력을 갖게 될 것이다.

**문서화**
실용주의 프로그래머는 문서화를 전체 개발 프로세스의 필수 불가결한 부분으로 받아들인다. ( 중 략 ) 바로 코드 안에 말이다.
소스 코드의 주석으로 보기 좋은 문서를 쉽게 생성할 수 있다. 모듈과 외부로 노출하는 함수에는 주석을 다는 것을 추천한다. API를 사용하려는 다른 개발자에게 도움이 될 것이다.
( 중 략 )
API가 아닌 코드에 주석을 쓸 때는 왜 이렇게 되어 있는지, 즉 코드의 용도와 목적을 논해야 한다. 어떻게 동작하는지는 코드가 이미 보여주기 때문에 이에 대해 주석을 다는 것은 사족이다. 게다가 이는 DRY 원칙 위반이다.
소스 코드에 다는 주석은 프로젝트에서 쉽게 누락되는 다른 곳에서 문서화 할 수 없는 부분을 문서화 하기에 최적의 기회다. 예를 들어 기술적인 절충점, 어떤 결정의 이유, 폐기한 다른 대안 등을 기술할 수 있다.

**도전해 볼 것**
- 청중이 누구이고 본인이 말하려는 것이 무엇인지 명확하게 도출하라.
> 

`🤔 오늘 읽은 소감은? 떠오르는 생각을 가볍게 적어보기` 

- 누군가는 말한다. 프론트엔드 개발자는 자고 일어나면 또 다른 기술이 생긴다고. 
또, 누군가는 끊임없이 공부해야 하는 직업인 ‘개발자’는 신에게서 버림받은 직업이라고도 했다.
그렇기 때문에 책 3쪽의 문단이 존재하는게 아닐까라고 생각한다.
    
    > 구직자에게 주도권이 있는 직업 순위를 뽑아 보면 소프트웨어 개발은 제일 윗부분에 자리잡을 것이다. 우리 기술은 수요가 많고, 우리의 지식은 지리적인 경계를 뛰어넘으며, 원격으로도 일할 수 있다. 보수도 후한 편이다. 우리는 원하는 것은 거의 무엇이든 할 수 있다.
    > 
- 이번 1장을 읽으며 **실용주의 프로그래머**의 본질, 특성, 될 방향을 학습했다.
실용주의 프로그래머가 되기 위해 끊임없이 공부하는 것, 그리고 올바른 소통의 힘이 얼마나 강한지도 또 한번 깨달았다.
Tip 들을 깊이 새기며 실용주의 프로그래머에 다가가기 위해 한 발자국씩 실천해보자!

`🔎 궁금한 내용이 있거나, 잘 이해되지 않는 내용은?`

- DRY 원칙
- ETC(Easier to Change) 설계 원칙

`👀 오늘 읽은 다른 사람의 TIL`

1. **[parksolo](https://nomadcoders.co/users/parksolo) 님의 TIL**

[TIL 서문~1장. 실용주의 철학 - 노마드 코더 Nomad Coders](https://nomadcoders.co/community/thread/3585)

1. **[yungimok](https://nomadcoders.co/users/yungimok) 님의 TIL**

[https://nomadcoders.co/community/thread/3582](https://nomadcoders.co/community/thread/3582)

1. **[hyune--4KXjeq](https://nomadcoders.co/users/hyune--4KXjeq) 님의 TIL**

[[TIL 1] 실용주의 프로그래머 #1. 실용주의 철학](https://hyuuny.tistory.com/54)

---

## DAY 03 (2022.05.15~16)

## 2장. 실용주의 접근법

`📝 오늘 읽은 범위`

### **2장. 실용주의 접근법**

항목 8. 좋은 설계의 핵심

항목 9. DRY: 중복의 해악

항목 10. 직교성

항목 11. 가역성

항목 12. 예광탄

항목 13. 프로토타입과 포스트잇

항목 14. 도메인 언어

항목 15. 추정

`📝 오늘 TIL 3줄 요약`

1. 잘 설계된 코드는 바뀜으로써 사용하는 사람에게 맞춰져야 한다.
그래서 우리는 ETC 원칙을 따른다. 바꾸기 더 쉽게 (Easier to Change). ETC. 이게 전부다.
2. 프로그래머는 늘 유지 보수 모드에 있다. 우리의 이해는 날마다 바뀐다. 
유지 보수는 별개의 활동이 아니며 전체 개발 과정의 일상적인 부분이다.
3. 예광탄 개발 방법은 점진적인 접근 방법이다.
예광탄 코드는 한 번 쓰고 버리려고 만드는 것이 아니다. 앞으로도 계속 사용할 코드다. 예광탄 코드에는 아직 모든 기능이 들어 있지 않을 뿐이다. 하지만 시스템을 구성하는 요소를 모두 연결해 놓은 후라면 목표물에 얼마나 근접했는지 확인할 수 있으며 필요하다면 조정도 할 수 있다. 일단 정확하게 조준하고 나면 기능을 추가하는 일은 쉽다. 

`💡 책에서 기억하고 싶은 내용` 

### Topic 8. 좋은 설계의 핵심

> **[ TIP 14. 좋은 설계는 나쁜 설계보다 바꾸기 쉽다. ]**
어떤 게 잘 설계되었다는 건 그 물건이 사용하는 살마에게 적응하여 맞춰진다는 것이다. 이 말을 코드에 적용해 보면, 잘 설계된 코드는 바뀜으로써 사용하는 사람에게 맞춰져야 한다.
그래서 우리는 ETC 원칙을 따른다. 바꾸기 더 쉽게 (Easier to Change). ETC. 이게 전부다.
왜 결합도를 줄이면 좋은가? ETC.
왜 단일 책임 원칙(Single Responsibility Principle)이 유용한가?  ETC.
왜 이름 짓기가 중요한가?  ETC!
> 

**ETC는 규칙이 아니라 가치**

> 어떻게 가치를 내면화할 수 있을까? 우리의 경험에 따르면 초기에는 어느 정도 의식적으로 노력해야 한다. 스스로 자꾸 물어보라. ‘내가 방금 한 일이 전체 시스템을 바꾸기 쉽게 만들었을까, 어렵게 만들었을까?’
( 중 략 )
하지만 가끔은 아무 실마리가 없을 수도 있다. 그래도 괜찮다. 이런 경우 다음 두 가지를 해보라.
첫 번째로, 앞으로 어떤 모습으로 바뀔지 잘 모르겠을 때 언제건 궁극의 ‘바꾸기 쉽게’라는 길을 선택한다. ( 중 략 ) 교체 가능하게 작성하라는 말은 코드의 결합도를 낮추고 응집도를 높이라는 이야기일 뿐이다.
두 번째는 이런 경우를 여러분의 직관을 발전시키는 기회로 삼으라는 것이다. 엔지니어링 일지에 현재 상황과 여러분의 선택, 그리고 변경 사항에 대한 추측을 정리해 둬라. 그리고 소스 코드에 이에 대한 표시를 남겨 둬라.
> 

### Topic 9. DRY: 중복의 해악

> 프로그래머로서 우리는 지식을 수집하고, 조직하고, 유지하며 통제한다.
( 중 략 )
안타깝게도 지식은 고정적이지 않다. 지식은 변화한다. 때로는 급격하게 변화한다.
( 중 략 )
이러한 불안정성은 우리 모두가 소위 유지 보수 모드에서 시스템에 반영된 지식을 재조직하고 다시 표현하면서 대부분의 시간을 보내게 되리라는 것을 의미한다.
사람들은 대부분 유지 보수란 버그를 고치고 기능을 개선하는 것을 의미하기 때문에, 애플리케이션이 출시되었을 때 비로소 유지 보수가 시작된다고 믿는다. 우리는 이들이 틀렸다고 생각한다. 프로그래머는 늘 유지 보수 모드에 있다. 우리의 이해는 날마다 바뀐다.
( 중 략 ) 유지 보수는 별개의 활동이 아니며 전체 개발 과정의 일상적인 부분이다.
( 중 략 )
소프트웨어를 신뢰성 톺게 개발하는 유일한 길, 개발을 이해하고 유지 보수하기 쉽게 만드는 유일한 길은 우리가 DRY라 부르는 원칙을 따르는 것이라 생각한다.
DRY 원칙 : 모든 지식은 시스템 내에서 단 한 번 만, 애매하지 않고, 권위있게 표현되어야 한다.
**[ Tip 15. DRY: 반복하지 말라 (Dont’ Repeat Yourself) ]**

DRY는 *지식의 중복*, *의도의 중복*에 대한 것이다 ⇒ 코드 뿐만이 아니다.
> 

**모든 코드 중복이 지식의 중복은 아니다.**

**데이터의 DRY 위반**

> 자료 구조는 지식을 표현한다. 그리고 DRY 원칙을 위배할 수 있다.
( 중 략 )
요령은 중복의 영향을 국소화 하는 것이다. 바깥세상에는 DRY 원칙 위배를 노출하지 않는다. 대신 클래스 내의 메서드가 좀 고생하면 된다.
( 중 략 )
중요한 시사점을 한 가지 던져준다. 모듈이 자료 구조를 노출하면 언제나 모듈의 구현과 그 자료 구조를 사용하는 코드 사이에 결합이 생긴다. 가능하다면 언제나 객체 속성을 읽고 쓸 때 접근자(accessor) 함수를 사용하라. 그러면 나중에 기능을 추가하기 더 쉬워질 것이다.

접근자 함수의 사용 → **버트런드 마이어(Bertrand Meyer)** → 단일 접근 원칙(Uniform Access principle)
”모듈을 통해 제공되는 모든 서비스는 일관적인 표기법(notation)으로 사용할 수 있어야 한다. 저장한 값으로 구현되었건, 계산을 통해 구현되었건 상관없이.”
> 

**표현상의 중복**

> 코드는 바깥세상과 연결된다.
1. 다른 라이브러리와는 API로
2. 다른 서비스와는 원격 호출이나 외부 저장소의 데이터 등으로
그리고 이렇게 연결될 때마다 일종의 DRY 위반을 하게 된다.
( 중 략 )
이런 중복을 아예 피할 수는 없지만 다소 완화할 수는 있다.

**1. 내부 API에서 생기는 중복**
⇒ 언어나 기술에 중립적인 형식으로 내부 API를 정의할 수 있는 도구를 찾아보고 이 도구를 이용하여 모든 API 정의를 중앙 저장소에 넣어두고 여러 팀이 공유할 수 있게 한다.

**2. 외부 API에서 생기는 중복**
⇒ 공개 API를 OpenAPI 같은 형식으로 엄밀하게 문서화 하는 경우가 점점 많아지고 있으므로 이러한 형식의 API 명세를 본인의 API 도구로 불러와서 사용 (신뢰성 ↑ 하게 해당 서비스 연동 O)

**3. 데이터 저장소와의 중복**
⇒ 많은 데이터 저장소가 데이터 스키마 분석 기능을 제공. 저장된 데이터를 객체로 옮기기 위한 코드를 손으로 만드는 것이 아니라, 스키마로부터 생성해낼 수 있다. 이와 같은 일을 줄여주는 영속성 프레임 워크(persistence framework)도 많이 있다.
> 

**개발자 간의 중복**

> 똑같은 일을 하는 코드가 우연히 중복으로 추가될 수 있고, 이런 중복은 수년 동안 발견되지 않을 수 있다. 결국 유지보수 문제로 귀결될 것이다.
( 중 략 )
개발자 간의 중복에 대처하려면 크게는 의사소통을 잘하는 튼튼하고 유대가 돈독한 팀을 만들어야 한다.
( 중 략 )
우리가 느끼기에 최선책은 개발자 간에 적극적이고 빈번한 소통을 장려하는 것이다.
팀원 한 사람을 프로젝트 사서로 임명하라 ⇒ 프로젝트 사서의 역할은 지식 교환을 돕는 것이다.
일상적으로든 코드 리뷰를 통해서든 다른 사람의 소스 코드와 문서를 반드시 읽어라. 기웃거리는 게 아니고, 거기서 배우는 것이다. 그리고 기억하라. 접근은 상호적이다.
**[ Tip 16. 재사용하기 쉽게 만들어라 ]**
> 

### Topic 10. 직교성

> 직교성(orthogonality)은 설계와 빌드, 테스트, 확장이 쉬운 시스템을 만드는 데에 있어 매우 중요한 개념이다.
> 

**직교성이란**

> 컴퓨터 과학에서 이 용어는 일종의 독립성이나, 결합도 줄이기(decoupling)을 의미한다. 하나가 바뀌어도 나머지에 어떤 영향도 주지 않으면 서로 직교한다고 할 수 있다.

**비-직교적인 시스템**
( 중 략 ) 모든 행동이 그에 따른 파생 효과를 일으킨다는 걸 깨닫는다.
( 중 략 ) 작업 부하가 엄청나다.
> 

**직교성의 장점**

> 시스템의 컴포넌트들이 고도로 상호 의존적인 경우, 특정 부분만 국지적으로 수정하는 방법이란 없다.
**[ Tip 17. 관련 없는 것들 간에 서로 영향이 없도록 하라 ]**
우리가 설계하고 싶은 것은 자족적(self-contained)인 컴포넌트, 즉 단일하고 잘 정의된 목적을 가진 독립적인 컴포넌트다.
( 중 략 )
직교적인 시스템을 작성하면 두 가지 큰 장점이 있다. 바로 생산성 향상과 리스크 감소다.
> 

**설계**

> 계층 구조는 직교적 시스템을 설계하는 강력한 방법이다. 각 계층은 자기 바로 밑에 있는 계층이 제공하는 추상화만을 사용하기 때문에, 다른 코드에 영향을 끼치지 않으면서 기반 구현들을 변경할 수 있게 되어 유연성이 높아진다. 또한, 모듈 간에 의존성이 폭증할 위험을 줄인다.
> 
> 
> ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f175c17e-4c4c-4b43-8552-cffce0eb99ca/Untitled.png)
> 
> ( 중 략 )
> 직교적인 시스템에서는 답이 ‘하나’여야 한다.
> ( 중 략 ) 또한, 현실 세계의 변화와 설계 사이의 결합도를 얼마나 줄였는지도 확인해 보길 바란다. ( 중 략 ) 자신의 힘으로 제어할 수 없는 속성에 의존하지 말라.
> 

**툴킷과 라이브러리**

> 외부에서 만든 툴킷이나 라이브러리를 도입할 때 시스템의 직교성을 해치지 않는지 주의 깊게 살펴보기 바란다. 기술을 현명하게 선택하길 바란다.
( 중 략 )
만약 객체를 저장소에 저장하는 방식이 투명하다면 직교적.
하지만 특별한 방식으로 객체를 생성하고 접근해야 한다면 그렇지 않다.
> 

**코딩**

> 직교성을 유지하기 위해 사용할 수 있는 몇 가지 기법

1. 코드의 결합도를 줄여라
⇒ ‘부끄럼쟁이(shy)’ 코드를 작성하라. 즉, 불필요한 것은 다른 모듈에 보여주지 않으며, 다른 모듈의 구현에 의존하지 않는 코드를 작성하라.
2. 전역 데이터를 피하라.
⇒ singleton pattern은 특정 클래스의 객체가 단 하나의 인스턴스만을 갖도록 보장해준다. 
그러나 많은 개발자가 이를 일종의 전역 데이터로 남용한다. 싱글턴을 사용할 때는 주의를 기울여라.
싱글턴은 불필요한 결합을 만들 수 있다. 
3. 유사한 함수를 피하라.
⇒ <<GOF의 디자인 패턴>>에서 소개하는 전략 패턴(strategy pattern)을 사용하여 더 낫게 구현할 수 없는지 고민하자.

자신의 작성하는 코드를 항상 비판적으로 바라보는 습관을 길러라. 기회가 있을 때마다 코드의 구조와 직교성을 개선하기 위해 노력하라. 이러한 과정을 Refactoring이라 부른다.
> 

**테스트**

> 직교적으로 설계하고 구현한 시스템은 테스트하기 더 쉽다. ( 중 략 ) 테스트를 정규 빌드 과정의 일부로 수행하는 것을 추천한다.
( 중 략 )
테스트를 마친 뒤 코드를 병합할 때 버그 수정에 대한 태그를 붙여라. 이렇게 하면 버그 수정마다 수정한 소스 파일 개수를 수집하여 그 경향을 분석한 월 단위 리포트를 만들 수 있을 것이다.
> 

**문서화**

> 정말 직교적인 문서라면 내용 변화 없이 모양새를 완전히 바꿀 수 있을 것이다.
> 

**직교적으로 살아가기**

> DRY 원칙으로 무장하고 직교성 원칙을 충실히 적용한다면 개발하고 있는 시스템이 더 유연하고 이해하기 쉬워질 것이다. 디버깅, 테스트, 유지보수 또한 쉬워질 것이다.
> 

### Topic 11. 가역성

> 당신이 가진 생각이 딱 하나밖에 없다면, 그것만큼 위험한 것은 없다.
- 에밀 오귀스트 샤르티에
> 

> 문제는 중요한 결정은 쉽게 되돌릴 수 없다는 데 있다.
> 

**가역성**

> 되돌릴 수 없는 결정을 줄여야 하는 까닭은 우리가 프로젝트 초기에 늘 최선의 결정을 내리지는 못하기 때문이다.
> 

**유연한 아키텍처**

> 많은 사람들이 코드를 유연하게 유지하려고 노력한다. 그런데 아키텍처, 배포, 외부 제품과의 통합 영역을 유연하게 유지하는 데에도 관심을 기울일 필요가 있다.
( 중 략 )
할 수 있는 것은 바꾸기 쉽게 만드는 것이다.
( 중 략 )
상자를 열어 보았을 때야 비로소 본인이 어떤 우주에 속해 있는지 알 수 있다. ( 중 략 ) 각각의 결정은 다른 버전의 미래를 야기한다.
( 중 략 )
상자를 열 용기가 있는가?
> 

### Topic 12. 예광탄

> 움직이는 목표물을 맞히려면 실제 조건 하에서 즉각적인 피드백을 받아야 한다.
> 

**어둠 속에서 빛을 내는 코드**

> 실용적인 관점에서 봐도 예광탄은 상대적으로 비용이 적게 드는 방법이다.
( 중 략 )
시스템을 정의하는 중요한 요구 사항을 찾아라. 의문이 드는 부분이나 가장 위험이 커 보이는 곳을 찾아라. 이런 부분의 코드를 가장 먼저 작성하도록 개발 우선순위를 정하라.
( 중 략 )
그 후에는 전체 애플리케이션에서 불확실한 곳이 어디인지 찾아보고 해당 부분을 작동시키는데 필요한 뼈대를 추가한다.
( 중 략 )
예광탄 코드는 한 번 쓰고 버리려고 만드는 것이 아니다. 앞으로도 계속 사용할 코드다.
( 중 략 ) 예광탄 코드에는 아직 모든 기능이 들어 있지 않을 뿐이다. 하지만 시스템을 구성하는 요소를 모두 연결해 놓은 후라면 목표물에 얼마나 근접했는지 확인할 수 있으며 필요하다면 조정도 할 수 있다. 일단 정확하게 조준하고 나면 기능을 추가하는 일은 쉽다.
( 중 략 )
예광탄 개발 바법은 점진적인 접근 방법이다.

장점
1. 사용자가 뭔가 작동하는 것을 일찍부터 보게 된다.
2. 개발자가 들어가서 일할 수 있는 구조를 얻는다.
3. 통합 작업을 수행할 기반이 생긴다.
4. 보여줄 것이 생긴다.
5. 진행 상황에 대해 더 정확하게 감을 잡을 수 있다.
> 

**예광탄이 언제나 목표물을 맞히는 것은 아니다.**

> 예광탄은 지금 맞히고 있는 것이 무엇인지 보여준다. 그러나 그것이 꼭 목표물이라는 보장은 없다. 그럴 경우 목표물에 맞을 때까지 조준을 옮겨야 한다. 이것이 핵심이다.
예광탄 코드 기법은 일이 어떻게 될지 100% 확신할 수 없는 상황에서 사용된다.
( 중 략 ) 그러니 지금 있는 것을 목표물에 더 가까워지도록 바꿔라.
> 

`🤔 오늘 읽은 소감은? 떠오르는 생각을 가볍게 적어보기` 

- 프로그래머는 늘 유지 보수 모드에 있다는 것을 잊지말고 ETC 원칙을 적용해보자!

`🔎 궁금한 내용이 있거나, 잘 이해되지 않는 내용은?`

- 데메테르 법칙

`👀 오늘 읽은 다른 사람의 TIL`

- **[yesl00k624](https://nomadcoders.co/users/yesl00k624)님의 TIL**

[[TIL 1] 실용주의 프로그래머 #2. 실용주의 접근법 - 노마드 코더 Nomad Coders](https://nomadcoders.co/community/thread/3536)

--- 

## DAY 08 (2022.05.??)

## **복습 3, 4장**

## **Mission 1**

1. 오늘의 책읽기: 복습 (3, 4장)
2. 오늘의 과제: 퀴즈를 풀면서 복습하기

`📝 오늘 복습할 범위`

**[DAY 02]** 서문 ~ 1장. 실용주의 철학

**[DAY 03]** 2장. 실용주의 접근법

`💡 Mission : 나의 최애 Book TIL`

### Question 1 of 5

What is the best format to keep knowledge on?

- [ ]  Plan Text
- [ ]  Encrypted Text

### Question 2 of 5

What does WYSIWYG mean?

- [ ]  Where You Seat is Where You Go
- [ ]  What You See is What You Get

### Question 3 of 5

What does VCS mean?

- [ ]  Version Control System
- [ ]  Verification Control System

### Question 4 of 5

Where should we use Version Control?

- [ ]  Everywhere
- [ ]  At work

### Question 5 of 5

What was the first computer bug?

- [ ]  A COBOL error
- [ ]  An ant
- [ ]  A moth

---

[#코딩](https://www.instagram.com/explore/tags/%EC%BD%94%EB%94%A9/) [#개발자](https://www.instagram.com/explore/tags/%EA%B0%9C%EB%B0%9C%EC%9E%90/) [#노마드북클럽](https://www.instagram.com/explore/tags/%EB%85%B8%EB%A7%88%EB%93%9C%EB%B6%81%ED%81%B4%EB%9F%BD/) [#노개북](https://www.instagram.com/explore/tags/%EB%85%B8%EA%B0%9C%EB%B6%81/)
